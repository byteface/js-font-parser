/*   Licensed to the Apache Software Foundation (ASF) under one or more   contributor license agreements.  See the NOTICE file distributed with   this work for additional information regarding copyright ownership.   The ASF licenses this file to You under the Apache License, Version 2.0   (the "License"); you may not use this file except in compliance with   the License.  You may obtain a copy of the License at       http://www.apache.org/licenses/LICENSE-2.0   Unless required by applicable law or agreed to in writing, software   distributed under the License is distributed on an "AS IS" BASIS,   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the License for the specific language governing permissions and   limitations under the License.      Converts a TrueType font to an SVG embedded font.   @author java <a href="mailto:david@steadystate.co.uk">David Schweinsberg</a>   ported to as3 <a href="mailto:byteface@googlemail.com">Michael Lawrence</a>   ported to javascript <a href="mailto:byteface@googlemail.com">Michael Lawrence</a>*/SVGFont = Class.extend({    EOL:"",    PROPERTY_LINE_SEPARATOR:"line.separator",    PROPERTY_LINE_SEPARATOR_DEFAULT:"\n",    DEFAULT_FIRST:32,    DEFAULT_LAST:128,    QUOT_EOL:XMLConstants.XML_CHAR_QUOT + this.EOL,        // Defines the application arguments.    CONFIG_USAGE:"SVGFont.config.usage",    /**    * Defines the start of the generated SVG document    * {0} SVG public ID    * {1} SVG system ID    */    CONFIG_SVG_BEGIN:"SVGFont.config.svg.begin",    /**    * Defines the SVG start fragment that exercise the generated    * Font.    */    CONFIG_SVG_TEST_CARD_START:"SVGFont.config.svg.test.card.start",    /**    * Defines the end of the SVG fragment that exercise the generated    * Font.    */    CONFIG_SVG_TEST_CARD_END:"SVGFont.config.svg.test.card.end",    ARG_KEY_START_CHAR:'-',    ARG_KEY_CHAR_RANGE_LOW:"-l",    ARG_KEY_CHAR_RANGE_HIGH:"-h",    ARG_KEY_ID:"-id",    ARG_KEY_ASCII:"-ascii",    ARG_KEY_AUTO_RANGE:"-autorange",        font:null,        FONT_DATA:"", // here we can store the data required by the browser to render these fonts	init: function( font ){    // inc("com/byteface/font/data/RawFont.js");    // inc("com/byteface/font/Class.js");    // inc("com/byteface/font/constants/CSSConstants.js");    // inc("com/byteface/font/constants/SVGConstants.js");    // inc("com/byteface/font/constants/XMLConstants.js");    // inc("com/byteface/font/PrintStream.js");        // inc("com/byteface/font/table/GsubTable.js");    // inc("com/byteface/font/table/KernTable.js");    // inc("com/byteface/font/table/GlyfCompositeComp.js");    this.font = font;    var args = [];        var low = 10;//this.parseArgs( args, this.ARG_KEY_CHAR_RANGE_LOW );    var high = 600;//this.parseArgs( args, this.ARG_KEY_CHAR_RANGE_HIGH );    var id = "DiscoMo";//this.parseArgs( args, this.ARG_KEY_ID );    var ascii = "";//this.parseArgs( args, this.ARG_KEY_ASCII );    var autoRange = "";//this.parseArgs( args, this.ARG_KEY_AUTO_RANGE );//alert(low + " | " + high+ " | " + id+ " | " + ascii+ " | " + autoRange );    var ps = new PrintStream();    //    this.writeSvgBegin(ps);    //this.writeSvgDefsBegin(ps);  //  this.writeFontAsSVGFragment( ps, this.font, id, (low != null ? low : -1), (high != null ? high : -1), (autoRange != null), (ascii != null) );//    this.writeSvgDefsEnd(ps);  //  this.writeSvgEnd(ps);//   ps.print();// ps.write( '<?xml version="1.0" standalone="no"?>');// ps.write( '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" ' );// ps.write( '"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">' );// ps.write( '<?xml-stylesheet type="text/css" href="./tests/resources/style/test.css" ?>');// ps.write( '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="450" height="500" viewBox="0 0 450 500">');ps.write( '<title>DiscoMo</title>' );ps.write( '<font id="DiscoMo" horiz-adv-x="1024" ><font-face' );ps.write( '    font-family="DiscoMo"');ps.write( '    font-style="normal"');ps.write( '    font-weight="600, 700, 800, 900"');ps.write( '    units-per-em="2048"');ps.write( '    panose-1="2 0 8 3 0 0 0 0 0 0"');ps.write( '    ascent="1567"');ps.write( '    descent="-481"');ps.write( '    alphabetic="0" />');ps.write( '<missing-glyph horiz-adv-x="2560" d="M2133 236Q2122 124 2108 43T2078 -88L587 1405Q641 1425 722 1439T912 1462L2133 236ZM419 958Q422 1017 431 1090Q440 1168 449 1218T468 1292L1963 -207Q1910 -225 -237T1631 -256L419 958ZM757 -227Q575 -200 521 -143Q495 -115 474 -57T439 92L757 -227ZM413 350Q407 470 407 612Q407 644 407 676Q407 708 409 737L1406 -264H1326Q1243 -264 1165 -261T1015 -254L413 350ZM2151 831Q2153 796 2153 757Q2153 718 2153 676Q2153 619 2152 563T2149 453L1132 1475Q1161 1477 1192 1477Q1224 1477 1256 1477Q1326 1477 1391 1475T1519 1468L2151 831ZM1777 1444Q1880 1427 1947 1403T2047 1348Q2111 1287 2135 1081L1777 1444ZM1592 1628L1586 1622Q1508 1627 1424 1629T1250 1632Q1106 1632 980 1626L978 1628L976 1626Q901 1621 830 1615T695 1599Q456 1566 384 1491Q349 1456 324 1376T282 1174Q274 1111 268 1044T259 907L251 897L257 889Q255 823 254 753T253 608Q253 442 259 295L251 283L261 270Q266 212 271 155T284 43Q301 -90 328 -172T390 -287Q481 -370 931 -403L937 -408L941 -403Q1032 -411 1130 -414T1334 -418Q2057 -418 2176 -299Q2252 -226 2287 172Q2298 302 2303 430T2309 686Q2309 1373 2190 1489Q2141 1537 1994 1570T1601 1620L1592 1628Z" />');ps.write( '</font>' );//ps.write( '</svg>' );// var obj = document.createElement("font");// obj.setAttribute("id", "DiscoMo");// obj.setAttribute("horiz-adv-x", 1024);// obj.setAttribute("data", actualSVG);// document.body.appendChild(obj);//this.FONT_DATA = obj;//ps.data;this.FONT_DATA = ps.data;}, writeSvgBegin: function(ps){    // ps.write("<?xml version=\"1.0\" standalone=\"no\"?>");    // ps.write("<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 20001102//EN\"");    // ps.write("\"http://www.w3.org/TR/2000/CR-SVG-20001102/DTD/svg-20001102.dtd\" >");    ps.write("<svg width=\"100%\" height=\"100%\">");}, writeSvgDefsBegin: function(ps){    // sb += ln("<defs>");    ps.write( XMLConstants.XML_OPEN_TAG_START + SVGConstants.SVG_DEFS_TAG + XMLConstants.XML_OPEN_TAG_END_CHILDREN );}, writeSvgDefsEnd: function(ps){    // sb += ln("</defs>");    ps.write( XMLConstants.XML_CLOSE_TAG_START + SVGConstants.SVG_DEFS_TAG + XMLConstants.XML_CLOSE_TAG_END );}, writeSvgEnd: function(ps){    // sb += ln("</svg>");    ps.write( XMLConstants.XML_CLOSE_TAG_START + SVGConstants.SVG_SVG_TAG + XMLConstants.XML_CLOSE_TAG_END );}, encodeEntities: function(s){    var sb = "";    for (var i=0; i < s.length; i++)    {        if(s.charAt(i) == XMLConstants.XML_CHAR_LT)        {            sb += (XMLConstants.XML_ENTITY_LT);        } else if(s.charAt(i) == XMLConstants.XML_CHAR_GT)        {            sb += (XMLConstants.XML_ENTITY_GT);        } else if(s.charAt(i) == XMLConstants.XML_CHAR_AMP)        {            sb += (XMLConstants.XML_ENTITY_AMP);        } else if(s.charAt(i) == XMLConstants.XML_CHAR_APOS)        {            sb += (XMLConstants.XML_ENTITY_APOS);        } else if(s.charAt(i) == XMLConstants.XML_CHAR_QUOT)        {            sb += (XMLConstants.XML_ENTITY_QUOT);        } else {            sb += (s.charAt(i));        }    }        return sb;}, getSVGFontFaceElement: function(font,ps){    var fontFamily = font.pName.getRecord(Table.nameFontFamilyName); // STILL TRACING WRONG    var unitsPerEm = font.head.unitsPerEm;    var panose = font.os2.panose.toString();    var ascent = font.hhea.ascender;    var descent = font.hhea.descender;    var baseline = 0; // bit 0 of head.flags will indicate if this is true            //alert( unitsPerEm +"||"+ panose +"||"+ ascent +"||"+ descent +"||"+ baseline )            //      <!ELEMENT font-face (%descTitleMetadata;,font-face-src?,definition-src?) >    //           <!ATTLIST font-face    //             %stdAttrs;    //             font-family CDATA #IMPLIED    //             font-style CDATA #IMPLIED    //             font-variant CDATA #IMPLIED    //             font-weight CDATA #IMPLIED    //             font-stretch CDATA #IMPLIED    //             font-size CDATA #IMPLIED    //             unicode-range CDATA #IMPLIED    //             units-per-em %Number; #IMPLIED    //             panose-1 CDATA #IMPLIED    //             stemv %Number; #IMPLIED    //             stemh %Number; #IMPLIED    //             slope %Number; #IMPLIED    //             cap-height %Number; #IMPLIED    //             x-height %Number; #IMPLIED    //             accent-height %Number; #IMPLIED    //             ascent %Number; #IMPLIED    //             descent %Number; #IMPLIED    //             widths CDATA #IMPLIED    //             bbox CDATA #IMPLIED    //             ideographic %Number; #IMPLIED    //             alphabetic %Number; #IMPLIED    //             mathematical %Number; #IMPLIED    //             hanging %Number; #IMPLIED    //             v-ideographic %Number; #IMPLIED    //             v-alphabetic %Number; #IMPLIED    //             v-mathematical %Number; #IMPLIED    //             v-hanging %Number; #IMPLIED    //             underline-position %Number; #IMPLIED    //             underline-thickness %Number; #IMPLIED    //             strikethrough-position %Number; #IMPLIED    //             strikethrough-thickness %Number; #IMPLIED    //             overline-position %Number; #IMPLIED    //             overline-thickness %Number; #IMPLIED >        ps.write( XMLConstants.XML_OPEN_TAG_START + SVGConstants.SVG_FONT_FACE_TAG + this.EOL );        ps.write( XMLConstants.XML_TAB + SVGConstants.SVG_FONT_FAMILY_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + fontFamily + this.QUOT_EOL );    //  += ("  font-family=\"") += (fontFamily) += ("\"\r\n")    ps.write( XMLConstants.XML_TAB + SVGConstants.SVG_UNITS_PER_EM_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + unitsPerEm + this.QUOT_EOL );    // += ("  units-per-em=\"") += (unitsPerEm) += ("\"\r\n")    ps.write( XMLConstants.XML_TAB + SVGConstants.SVG_PANOSE_1_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + panose + this.QUOT_EOL );    //  += ("  panose-1=\"") += (panose) += ("\"\r\n")    ps.write( XMLConstants.XML_TAB + SVGConstants.SVG_ASCENT_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + ascent + this.QUOT_EOL );    //  += ("  ascent=\"") += (ascent) += ("\"\r\n")    ps.write( XMLConstants.XML_TAB + SVGConstants.SVG_DESCENT_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + descent + this.QUOT_EOL );    //  += ("  descent=\"") += (descent) += ("\"\r\n")    ps.write( XMLConstants.XML_TAB + SVGConstants.SVG_ALPHABETIC_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + baseline + XMLConstants.XML_CHAR_QUOT );        ps.write( XMLConstants.XML_OPEN_TAG_END_NO_CHILDREN + this.EOL );    // += ("  baseline=\"") += (baseline) += ("\"/>\r\n");}/*** Returns a &lt;font&gt;&#x2e;&#x2e;&#x2e;&lt;/font&gt; block,* defining the specified font.** @param font The TrueType font to be converted to SVG* @param id An XML id attribute for the font element* @param first The first character in the output range* @param last The last character in the output range* @param forceAscii Force the use of the ASCII character map*/, writeFontAsSVGFragment: function( ps, font, id, first, last, autoRange, forceAscii ){    var horiz_advance_x = font.os2.xAvgCharWidth;        ps.write( XMLConstants.XML_OPEN_TAG_START );    ps.write( SVGConstants.SVG_FONT_TAG );    ps.write( XMLConstants.XML_SPACE );    // sb += ("<font ");        if (id != null)    {        ps.write( SVGConstants.SVG_ID_ATTRIBUTE );        ps.write( XMLConstants.XML_EQUAL_QUOT );        // sb += ("id=\"");        ps.write(id);        ps.write( XMLConstants.XML_CHAR_QUOT );        ps.write( XMLConstants.XML_SPACE );        // sb += ("\" ");    }        ps.write( SVGConstants.SVG_HORIZ_ADV_X_ATTRIBUTE );    ps.write( XMLConstants.XML_EQUAL_QUOT );    // sb += ("horiz-adv-x=\"");    ps.write( horiz_advance_x );    ps.write( XMLConstants.XML_CHAR_QUOT );    ps.write( XMLConstants.XML_OPEN_TAG_END_CHILDREN );    // sb += ln("\">");//    alert(font);    this.getSVGFontFaceElement(font,ps);        // Decide upon a cmap table to use for our character to glyph look-up    var cmapFmt = null;    if(forceAscii){        // We've been asked to use the ASCII/Macintosh cmap format        cmapFmt = font.cmap.getCmapFormat( Table.platformMacintosh, Table.encodingRoman );    } else {        // The default behaviour is to use the Unicode cmap encoding        cmapFmt = font.cmap.getCmapFormat( Table.platformMicrosoft, Table.encodingUGL );                //alert(cmapFmt.version);                if (cmapFmt == null) {            // This might be a symbol font, so we'll look for an "undefined" encoding            cmapFmt = font.cmap.getCmapFormat( Table.platformMicrosoft, Table.encodingUndefined );        }    }    if (cmapFmt == null)    {        alert("Cannot find a suitable cmap table");    }        //alert( ps.data);        // If this font includes arabic script, we want to specify    // substitutions for initial, medial, terminal & isolated    // cases.    var gsub = font.getTable(Table.GSUB);    //    alert(gsub)        var initialSubst = null;    var medialSubst = null;    var terminalSubst = null;    if (gsub != null)    {        // TODO-FIXME - i removed this too        var s = gsub.getScriptList().findScript(""); //.findScript(SCRIPT_TAG_ARAB);        if (s != null)        {            var ls = s.getDefaultLangSys();            if (ls != null) {                var init = gsub.getFeatureList().findFeature(ls, FeatureTags.FEATURE_TAG_INIT);                var medi = gsub.getFeatureList().findFeature(ls, FeatureTags.FEATURE_TAG_MEDI);                var fina = gsub.getFeatureList().findFeature(ls, FeatureTags.FEATURE_TAG_FINA);                    initialSubst = SingleSubst(gsub.getLookupList().getLookup(init, 0).getSubtable(0));                medialSubst = SingleSubst(gsub.getLookupList().getLookup(medi, 0).getSubtable(0));                terminalSubst = SingleSubst(gsub.getLookupList().getLookup(fina, 0).getSubtable(0));            }        }    }        // Include the missing glyph//    ps.write( this.getFullGlyphAsSVG( font, font.getGlyph(0), 0, horiz_advance_x, initialSubst, medialSubst, terminalSubst, "" ) );       //  alert( ps.data);       if(first == -1) {        if(!autoRange) first = this.DEFAULT_FIRST;        else            first = cmapFmt.getFirst();    }    if(last == -1) {        if(!autoRange) last = this.DEFAULT_LAST;        else            last = cmapFmt.getLast();    }    // Include our requested range    for(var i=first; i <= last; i++)    {        var glyphIndex = cmapFmt.mapCharCode(i);        //alert("lkjlkjhkljh"+glyphIndex+"|"+i);        if(glyphIndex > 0)        {            // TODO - FIXME - toHexString bit here               ps.write( this.getFullGlyphAsSVG( font, font.getGlyph(glyphIndex), glyphIndex, horiz_advance_x, initialSubst, medialSubst, terminalSubst,                (32<= i && i <= 127) ? this.encodeEntities( String(i) ) : XMLConstants.XML_CHAR_REF_PREFIX + i + XMLConstants.XML_CHAR_REF_SUFFIX) );        }    }    // Output kerning pairs from the requested range    var kern = font.getTable(Table.kern);        if(kern != null){        var kst = kern.getSubtable(0);        var post = font.getTable(Table.post);        for (var j=0; j < kst.getKerningPairCount(); j++)        {            ps.write( this.getKerningPairAsSVG( kst.getKerningPair(j), post) );        }    }    ps.write( XMLConstants.XML_CLOSE_TAG_START );    ps.write( SVGConstants.SVG_FONT_TAG );    ps.write( XMLConstants.XML_CLOSE_TAG_END );    // sb += ln("</font>");           // alert( ps.data);}, getGlyphAsSVG: function( font, glyph, glyphIndex, defaultHorizAdvanceX, attrib, code ){    var sb = "";    var firstIndex = 0;    var count = 0;    var i;    var horiz_advance_x;        // alert(font +"||"+ glyph +"||"+ glyphIndex +"||"+ defaultHorizAdvanceX +"||"+ attrib +"||"+ code );        horiz_advance_x = font.hmtx.getAdvanceWidth(glyphIndex);        if(glyphIndex == 0) {        sb += XMLConstants.XML_OPEN_TAG_START;        sb += SVGConstants.SVG_MISSING_GLYPH_TAG;        // sb += ("<missing-glyph");    } else {            // Unicode value        sb += XMLConstants.XML_OPEN_TAG_START;        sb += SVGConstants.SVG_GLYPH_TAG + XMLConstants.XML_SPACE + SVGConstants.SVG_UNICODE_ATTRIBUTE;        sb += XMLConstants.XML_EQUAL_QUOT + code + XMLConstants.XML_CHAR_QUOT;        // sb += ("<glyph unicode=\"") += (code) += ("\"");            // Glyph name        sb += XMLConstants.XML_SPACE + SVGConstants.SVG_GLYPH_NAME_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT;        // sb += (" glyph-name=\"")        sb += (font.post.getGlyphName(glyphIndex));        //  += ("\"");        sb += XMLConstants.XML_CHAR_QUOT;    }    if(horiz_advance_x != defaultHorizAdvanceX) {        sb += XMLConstants.XML_SPACE + SVGConstants.SVG_HORIZ_ADV_X_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT;        sb += horiz_advance_x + XMLConstants.XML_CHAR_QUOT;        // sb += (" horiz-adv-x=\"") += (horiz_advance_x) += ("\"");    }        if(attrib != null) {        sb += (attrib);    }        if(glyph != null) {        // sb += (" d=\"");        sb += XMLConstants.XML_SPACE + SVGConstants.SVG_D_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT;        for(i=0; i < glyph.getPointCount(); i++) {            count++;            if (glyph.getPoint(i).endOfContour) {                sb += (getContourAsSVGPathData(glyph, firstIndex, count));                firstIndex = i + 1;                count = 0;            }        }        // sb += ("\"");        sb += (XMLConstants.XML_CHAR_QUOT);    }        sb += XMLConstants.XML_OPEN_TAG_END_NO_CHILDREN;    // sb += ("/>");        // Chop-up the string into 255 character lines    this.chopUpStringBuffer(sb);        return sb;}	, getFullGlyphAsSVG: function( font, glyph, glyphIndex, defaultHorizAdvanceX, arabInitSubst, arabMediSubst, arabTermSubst, code ){   //alert(font +"||"+ glyph+"||"+ glyphIndex+"||"+ defaultHorizAdvanceX+"||"+ arabInitSubst+"||"+ arabMediSubst+"||"+ arabTermSubst+"||"+ code);    var sb = "";    var substituted = false;        // arabic = "initial | medial | terminal | isolated"    var arabInitGlyphIndex = glyphIndex;    var arabMediGlyphIndex = glyphIndex;    var arabTermGlyphIndex = glyphIndex;    if(arabInitSubst != null) {        arabInitGlyphIndex = arabInitSubst.substitute(glyphIndex);    }    if(arabMediSubst != null) {        arabMediGlyphIndex = arabMediSubst.substitute(glyphIndex);    }    if(arabTermSubst != null) {        arabTermGlyphIndex = arabTermSubst.substitute(glyphIndex);    }        if(arabInitGlyphIndex != glyphIndex) {        sb += (getGlyphAsSVG( font, font.getGlyph(arabInitGlyphIndex), arabInitGlyphIndex, defaultHorizAdvanceX,            // " arabic-form=\"initial\"",            (XMLConstants.XML_SPACE + SVGConstants.SVG_ARABIC_FORM_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + SVGConstants.SVG_INITIAL_VALUE + XMLConstants.XML_CHAR_QUOT ), code ) );        // sb += ("\r\n");        sb += EOL;        substituted = true;    }        if(arabMediGlyphIndex != glyphIndex) {        sb += (getGlyphAsSVG( font, font.getGlyph(arabMediGlyphIndex), arabMediGlyphIndex, defaultHorizAdvanceX,            // " arabic-form=\"medial\"",            ( XMLConstants.XML_SPACE + SVGConstants.SVG_ARABIC_FORM_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + SVGConstants.SVG_MEDIAL_VALUE + XMLConstants.XML_CHAR_QUOT), code ) );        // sb += ("\r\n");        sb += EOL;        substituted = true;    }        if(arabTermGlyphIndex != glyphIndex) {        sb += (getGlyphAsSVG( font, font.getGlyph(arabTermGlyphIndex), arabTermGlyphIndex, defaultHorizAdvanceX,            // " arabic-form=\"terminal\"",            ( XMLConstants.XML_SPACE + SVGConstants.SVG_ARABIC_FORM_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + SVGConstants.SVG_TERMINAL_VALUE + XMLConstants.XML_CHAR_QUOT ), code) );        // sb += ("\r\n");        sb += EOL;        substituted = true;    }        if(substituted) {        sb += (getGlyphAsSVG( font, glyph, glyphIndex, defaultHorizAdvanceX,            // " arabic-form=\"isolated\"",            ( XMLConstants.XML_SPACE + SVGConstants.SVG_ARABIC_FORM_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT + SVGConstants.SVG_ISOLATED_VALUE + XMLConstants.XML_CHAR_QUOT), code) );    } else {        sb += ( this.getGlyphAsSVG( font, glyph, glyphIndex, defaultHorizAdvanceX, null, code) );    }        return sb;}, getKerningPairAsSVG: function(kp,post){    var sb = "";    // sb += ("<hkern g1=\"");    sb += XMLConstants.XML_OPEN_TAG_START + SVGConstants.SVG_HKERN_TAG + XMLConstants.XML_SPACE;    sb += SVGConstants.SVG_G1_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT;    sb += post.getGlyphName(kp.getLeft());    // sb += ("\" g2=\"");    sb += XMLConstants.XML_CHAR_QUOT + XMLConstants.XML_SPACE + SVGConstants.SVG_G2_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT;    sb += (post.getGlyphName(kp.getRight()));    // sb += ("\" k=\"");    sb += XMLConstants.XML_CHAR_QUOT + XMLConstants.XML_SPACE + SVGConstants.SVG_K_ATTRIBUTE + XMLConstants.XML_EQUAL_QUOT;    // SVG kerning values are inverted from TrueType's.    sb += (-kp.getValue());    // sb += ("\"/>");    sb += XMLConstants.XML_CHAR_QUOT + XMLConstants.XML_OPEN_TAG_END_NO_CHILDREN;        return sb;}, getContourAsSVGPathData: function( glyph, startIndex, count ){    alert( glyph +"||"+ startIndex +"||"+ count );    // If this is a single point on it's own, we can't do anything with it    if(glyph.getPoint(startIndex).endOfContour)    {        return "";    }        var sb = "";    var offset = 0;        while (offset < count)    {        var point = glyph.getPoint(startIndex + offset%count);        var point_plus1 = glyph.getPoint(startIndex + (offset+1)%count);        var point_plus2 = glyph.getPoint(startIndex + (offset+2)%count);            if (offset == 0)        {            sb += (SVGConstants.PATH_MOVE);            sb += point.x;            sb += (XMLConstants.XML_SPACE);            sb += point.y;        }            if (point.onCurve && point_plus1.onCurve) {            if (point_plus1.x == point.x) {                // This is a vertical line                sb += (SVGConstants.PATH_VERTICAL_LINE_TO);                sb += String(point_plus1.y);            } else if (point_plus1.y == point.y)            {                // This is a horizontal line                sb += (SVGConstants.PATH_HORIZONTAL_LINE_TO);                sb += String(point_plus1.x);            } else {                sb += (SVGConstants.PATH_LINE_TO);                sb += (String(point_plus1.x));                sb += (XMLConstants.XML_SPACE);                sb += (String(point_plus1.y));            }            offset++;        } else if (point.onCurve && !point_plus1.onCurve && point_plus2.onCurve) {            // This is a curve with no implied points            sb += (SVGConstants.PATH_QUAD_TO);            sb += (String(point_plus1.x));            sb += (XMLConstants.XML_SPACE);            sb += (String(point_plus1.y));            sb += (XMLConstants.XML_SPACE);            sb += (String(point_plus2.x));            sb += (XMLConstants.XML_SPACE);            sb += (String(point_plus2.y));            offset+=2;        } else if (point.onCurve && !point_plus1.onCurve && !point_plus2.onCurve) {            // This is a curve with one implied point            sb += (SVGConstants.PATH_QUAD_TO);            sb += (String(point_plus1.x));            sb += (XMLConstants.XML_SPACE);            sb += (String(point_plus1.y));            sb += (XMLConstants.XML_SPACE);            sb += (String(midValue(point_plus1.x, point_plus2.x)));            sb += (XMLConstants.XML_SPACE);            sb += (String(midValue(point_plus1.y, point_plus2.y)));            offset+=2;        } else if (!point.onCurve && !point_plus1.onCurve) {            // This is a curve with two implied points            sb += (SVGConstants.PATH_SMOOTH_QUAD_TO)            sb += (String(midValue(point.x, point_plus1.x)))            sb += (XMLConstants.XML_SPACE)            sb += (String(midValue(point.y, point_plus1.y)));            offset++;        } else if (!point.onCurve && point_plus1.onCurve) {            sb += (SVGConstants.PATH_SMOOTH_QUAD_TO)            sb += (String(point_plus1.x))            sb += (XMLConstants.XML_SPACE)            sb += (String(point_plus1.y));            offset++;        } else {            alert( "drawGlyph case not catered for!" );                        break;        }    }    sb += (SVGConstants.PATH_CLOSE);        return sb;}, chopUpStringBuffer: function(sb){    if(sb.length < 256)    {        return;    } else {        // Being rather simplistic about it, for now we'll insert a newline after        // 240 chars        for(var i=240; i < sb.length; i++)        {            if (sb.charAt(i) == ' ')            {                   // TODO - FIXME - find method for this                //alert( "asdfasdfasdfasdfasd" );                sb.setCharAt(i, '\n');                i += 240;            }        }    }}, midValue: function(a,b){    return a + (b - a)/2;}, parseArgs: function(args,name){    for(var i=0; i < args.length; i++){        if(name == null){            if (args[i].charAt(0) != ARG_KEY_START_CHAR) {                return args[i];            }                        alert("TODOTDOTODOOTODO");            // TODO - FIXME - TODOD sort this bit out    //	            } else if (name.equalsIgnoreCase(args[i])) {    //	                if ((i < args.length - 1) && (args[i+1].charAt(0) != ARG_KEY_START_CHAR)) {    //	                    return args[i+1];    //	                } else {    //	                    return args[i];    //	                }        }    }    return null;}});